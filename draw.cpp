/*****************************************************************
 * draw.cpp
 *
 * Copyright 2012-2014, Hendrik Radke
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the license contained in the
 * COPYING file.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * Fill text bubbles of a comic with text, according to an XML
 * file as generated by detect.cpp.
 */

#include "comicfile.hpp"
#include <fstream>

int main(int argc, char *argv[]) {
    if(argc == 2) {
	parse_XML(argv[1]);
    } else {
	std::cerr<< "usage: "<< argv[0] <<" <XML file>\n";
	exit(-1);
    }
    exit(0);
}

int ellipseWidth(float a, float b, float y) {
    // Ellipsen-Gleichung x^2/a^2 - y^2/b^2 = 1, umgestellt nach x
    return static_cast<int>(round(sqrt((1.0 - (y*y)/(b*b)) * (a*a))*2.0));
}

string replace_all(string str, string from, string to) {
    string::size_type pos = 0;
    while( (pos = str.find(from, pos)) != string::npos) {
	str.replace(pos, from.size(), to);
	pos++;
    }
    return str;
}

string drawTextLine(int x0, int y0, string text, int maxwidth, float rel_height, bool centered=true) {
    string prefix = "", oldprefix = "";
    int height, width = 0;
    while (width < maxwidth && oldprefix != text) {
	oldprefix = prefix;
	// Find the next word boundary
	size_t len = prefix.length();
	size_t word_idx = text.find(" ", len+1);
	
	if (word_idx != string::npos) {
	    prefix = text.substr(0, word_idx);
	} else {
	    prefix = text;
	}
	imlib_get_text_size(prefix.c_str(), &width, &height);
    }
    
    imlib_get_text_size(oldprefix.c_str(), &width, &height);
    int xpos = x0 + 2;
    if (centered) xpos += (maxwidth-width)/2;
    int ypos = y0 - height/2 - static_cast<int>(round(1.1*rel_height*(height/2.0)));
    imlib_text_draw(xpos, ypos, replace_all(oldprefix, "~", " ").c_str());
    //imlib_image_draw_line(x0, y0, x0+maxwidth, y0, 0);
    if (oldprefix == text) return "";
    else                   return text.substr(oldprefix.length()+1);
}

void Bubble::draw() {
    int len = text.length();
    int fontsize = static_cast<int>(round(atof(fonts.back().size.c_str())));
    if (shape == "ellipse") {
	int centerx = arg_i(args, "centerx"),  centery = arg_i(args, "centery");
	int radiusx = arg_i(args, "radiusx"),  radiusy = arg_i(args, "radiusy");
	if (radiusx > centerx || radiusy > centery)
	    std::cerr<< "Warning: Ellipse Radii ("<< radiusx <<", "<< radiusy <<")"
		     << " > Midpoint ("<< centerx <<", "<< centery <<")\n";
	if (radiusx < 8) std::cerr<< "Warning: Ellipse x-Radius "<<radiusx<<" too small.\n";
	if (radiusy < 8) std::cerr<< "Warning: Ellipse y-Radius "<<radiusy<<" too small.\n";
	colors.back().use();
	imlib_image_fill_ellipse(centerx, centery, radiusx-1, radiusy-1);
	// Wähle die Höhe der 1. Zeile so, dass das 1. Wort gerade hineinpasst.
	int width, height;
	int first_idx     = text.find(' ');
	string first_word = (first_idx != string::npos) ? text.substr(0,first_idx) : text;
	fonts.back().use();
	imlib_get_text_size(first_word.c_str(), &width, &height);
	height = -radiusy;
	do {
	    height++;
	    //printf("%s of width %d does not fit into width %d, increase h to %d\n",
	    //first_word.c_str(), width, ellipseWidth(radiusx, radiusy, abs(height)), height);
	} while (ellipseWidth(radiusx, radiusy, abs(height)) < width && height <= 0);
	height += fontsize/3;
	// Schreibe den Text nacheinander in die Zeilen.
	string rest  = text;
	while(rest.length() > 0) {
	    if (height > radiusy-2) {
		std::cerr<< "Error: text does not fit, aborting: "<< text <<".\n";
		break;
	    }
	    width = ellipseWidth(radiusx, radiusy, abs(height));
	    rest = drawTextLine(centerx-width/2, centery+height, rest, width, height/(float)radiusx);
	    height += fontsize*1.7;
	}
    } else if (shape == "rectangle") {
	int x0    = arg_i(args, "x0"),    y0 = arg_i(args, "y0");
	int width = arg_i(args, "width"), height = arg_i(args, "height");
	if (width  < 8) std::cerr<< "Warning: Rectangle Width " <<width <<" too small.\n";
	if (height < 8) std::cerr<< "Warning: Rectangle Height "<<height<<" too small.\n";
	colors.back().use();
	imlib_image_fill_rectangle(x0, y0, width, height);
	// Text schreiben
	string rest  = text;
	int txtheight = 0.8*fontsize;
	fonts.back().use();
	while(rest.length() > 0) {
	    if (txtheight > height) {
		std::cerr<< "Error: text does not fit, aborting: "<< text <<".\n";
		break;
	    }
	    rest = drawTextLine(x0, y0+txtheight, rest, width, txtheight/(float)width, false);
	    txtheight += fontsize*1.7;
	}
	
    } else {
	std::cerr<< "Error: unknown bubble shape "<< shape <<"\n";
    }
}
